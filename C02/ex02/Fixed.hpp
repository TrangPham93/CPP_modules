/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Fixed.hpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: trpham <trpham@student.hive.fi>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/11 11:35:07 by trpham            #+#    #+#             */
/*   Updated: 2025/08/13 00:08:37 by trpham           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

# include <iostream>
# include <cmath>
# include <climits>

/* 
	Floating point number representation:
	number = (sign ? -1:1) * 2^(exponent) * 1.(mantissa bits) */

class Fixed
{
private:
	int					_rawValue;
	static const int	_fractionBit;
	
public:
	Fixed(void);

	/* 
	intNum << 8 = intNum * 2^8 = intNum * 256 = (1 << 8)
	left shift only work with int.
 	you always store numbers in _rawValue as an integer, but you interpret them as real numbers by dividing by 2fractionBit2fractionBit when reading
	int = 32 bits:[sign = 1 bit][interger bits = 23 bit][fraction bit = 8]*/
	Fixed(const int intNum);
	Fixed(const float fNum);
	~Fixed();
	
	/* copy constructor
	- default copy constructor == implicit copy constructor, generated by compiler: shallow copy of the data pointer.
	copy the address of the original data member
	- user-defined copy constructor == explicit copy constructor: to create a deep copy 
		. the const is optional but is added so that we do not modify the obj by mistake. 
		. we need to define our own copy constructor only if an object has pointers or 
		any runtime allocation of the resource like a file handle, a network connection, 
		etc because the default constructor does only shallow copy.*/
	Fixed(const Fixed& copy); 

	/* copy assignment operator:
	The main difference between Copy Constructor and Assignment Operator is that 
	the Copy constructor makes a new memory storage every time it is called 
	while the assignment operator does not make new memory storage. */
	Fixed& operator = (const Fixed& copy);

	/* Comparison operator */
	bool	operator > (const Fixed& other) const;
	bool	operator < (const Fixed& other) const;
	bool	operator >= (const Fixed& other) const;
	bool	operator <= (const Fixed& other) const;
	bool	operator == (const Fixed& other) const;
	bool	operator != (const Fixed& other) const;

	// Arithmetic operator
	Fixed	operator+ (const Fixed& other) const;
	Fixed	operator- (const Fixed& other) const;
	Fixed	operator* (const Fixed& other) const;
	Fixed	operator/ (const Fixed& other) const;
	
	/* Increment / decrement operator
		@return: increase or decrease the fixed-point value fromthe smallest representable Ïµ = 1 / 256 = 0.00390625 */ 
	Fixed&	operator++ (void); // prefix increment
	Fixed	operator++ (int); // postfix increment
	Fixed&	operator-- (void); // prefix increment
	Fixed	operator-- (int); // postfix increment
	
	// public overloaded member function
	static Fixed&		min (Fixed& a, Fixed& b);
	// @note: const at the end isn't relevant, cause static func not depend obj
	static const Fixed&	min (const Fixed& a, const Fixed& b);
	static Fixed&	max (Fixed& a, Fixed& b);
	static const Fixed&	max (const Fixed& a, const Fixed& b);

	int		getRawBits( void ) const;
	void	setRawBits( int const raw );
	float	toFloat( void ) const;
	int		toInt( void ) const;
};

/* Operator overloading:
	Redefine the way operator works for user-defined type
	Left side of operand is returned to ostream, so it cannot be inside class
*/
std::ostream& operator << (std::ostream& os, const Fixed& other);

